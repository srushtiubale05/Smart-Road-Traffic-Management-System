<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Stop-line Violation Detection</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* (styles same as before) */
      body {
        font-family: "Poppins", sans-serif;
        background: #071020;
        color: #e8f8f8;
        margin: 0;
        padding: 24px;
      }
      a.back-btn {
        position: fixed;
        left: 16px;
        top: 16px;
        background: rgba(0, 0, 0, 0.45);
        color: #fff;
        padding: 8px 10px;
        border-radius: 8px;
        text-decoration: none;
        z-index: 2000;
      }
      a.back-btn:hover {
        background: rgba(0, 0, 0, 0.65);
      }
      .container {
        max-width: 1100px;
        margin: 48px auto;
      }
      h1 {
        text-align: center;
        margin-bottom: 8px;
        color: #bfefff;
      }
      .upload-box {
        margin: 18px auto;
        border: 2px dashed rgba(190, 239, 255, 0.12);
        border-radius: 12px;
        padding: 26px;
        text-align: center;
        cursor: pointer;
        max-width: 900px;
        background: rgba(255, 255, 255, 0.01);
        transition: all 0.3s;
      }
      .upload-box:hover {
        border-color: rgba(190, 239, 255, 0.25);
      }
      .upload-box.dragover {
        border-color: #00e1ff;
        box-shadow: 0 6px 20px rgba(0, 225, 255, 0.06);
        background: rgba(0, 225, 255, 0.02);
      }
      .upload-box input {
        display: none;
      }
      .preview-row {
        display: flex;
        gap: 18px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 18px;
      }
      .video-box {
        background: rgba(255, 255, 255, 0.02);
        padding: 12px;
        border-radius: 8px;
        width: 48%;
        min-width: 300px;
        box-sizing: border-box;
        text-align: center;
      }
      .video-box video {
        max-width: 100%;
        border-radius: 6px;
        border: 3px solid rgba(255, 255, 255, 0.04);
        display: block;
        margin: 0 auto;
        background: #000;
      }
      #resultBox {
        margin-top: 18px;
        text-align: center;
      }
      .btn {
        margin-top: 12px;
        padding: 10px 14px;
        background: #00c7a7;
        color: #001;
        border: none;
        border-radius: 8px;
        font-weight: 700;
        cursor: pointer;
        font-family: "Poppins", sans-serif;
        transition: all 0.2s;
      }
      .btn:hover:not([disabled]) {
        background: #00e1c0;
        transform: translateY(-1px);
      }
      .btn[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }
      .small {
        font-size: 0.9rem;
        color: #bfefff;
      }
      .hidden {
        display: none;
      }
      .spinner {
        display: inline-block;
        width: 18px;
        height: 18px;
        border: 3px solid rgba(255, 255, 255, 0.12);
        border-top-color: #00e1ff;
        border-radius: 50%;
        animation: spin 0.9s linear infinite;
        margin-left: 8px;
        vertical-align: middle;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .plates {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 12px;
      }
      .plate-thumb {
        width: 160px;
        border-radius: 6px;
        border: 2px solid rgba(255, 255, 255, 0.04);
        transition: transform 0.2s;
      }
      .plate-thumb:hover {
        transform: scale(1.05);
        border-color: rgba(0, 225, 255, 0.3);
      }
      .status {
        color: #aeefff;
        font-weight: 700;
        margin-top: 10px;
      }
      .note {
        color: #bfefff;
        font-size: 0.95rem;
        margin-top: 8px;
      }
      .error-detail {
        background: rgba(255, 107, 107, 0.1);
        border: 1px solid rgba(255, 107, 107, 0.3);
        padding: 10px;
        border-radius: 6px;
        margin-top: 10px;
        font-size: 0.9rem;
      }
      /* progress UI */
      .progress-wrapper {
        display: inline-flex;
        align-items: center;
        gap: 16px;
        justify-content: center;
        margin-top: 14px;
      }
      .progress-ring {
        width: 96px;
        height: 96px;
        position: relative;
      }
      .progress-ring svg {
        transform: rotate(-90deg);
        width: 96px;
        height: 96px;
      }
      .progress-text {
        position: absolute;
        left: 0;
        top: 0;
        width: 96px;
        height: 96px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        color: #bfefff;
      }
      .progress-label {
        font-size: 0.9rem;
        color: #bfefff;
      }
      @media (max-width: 880px) {
        .video-box {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <a href="/dashboard" class="back-btn">‚¨Ö Back</a>
    <div class="container" role="main" aria-labelledby="pageTitle">
      <h1>SmartRaahi</h1>
      <h1 id="pageTitle">üö¶ Stop-line Violation Detection</h1>
      <p class="note" style="text-align: center">
        Upload a video. Server will process it and detect vehicles crossing the
        stop-line, capturing their number plates.
      </p>

      <div
        id="dropZone"
        class="upload-box"
        tabindex="0"
        aria-label="Upload video for stopline detection"
      >
        <p style="font-size: 1.05rem; color: #dff8ff; margin: 6px 0">
          üìπ Drag & drop a video here ‚Äî or click to choose
        </p>
        <p class="small">
          Supported: .mp4 .mov .avi .mkv (recommend under 60s). Max ~100MB.
        </p>
        <input id="fileInput" type="file" accept="video/*" />
        <div
          id="dropMsg"
          style="margin-top: 12px; color: #aeeeff; font-weight: 600"
        >
          No file chosen
        </div>
      </div>

      <div id="previewContainer" class="hidden" aria-live="polite">
        <div
          class="preview-row"
          role="region"
          aria-label="Video preview and outputs"
        >
          <div class="video-box">
            <h3 style="color: #bfefff; margin: 6px 0">üì• Selected Video</h3>
            <video id="inputVideo" controls muted></video>
            <div class="note" id="fileInfo"></div>
          </div>
          <!-- <div
            class="video-box"
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              min-height: 120px;
            "
          >
            <div style="text-align: center; max-width: 260px" class="note">
              Results (plates) will appear below after processing.
            </div> -->
          </div>
        </div>

        <div id="resultBox">
          <div style="margin-top: 10px">
            <button id="processBtn" class="btn">üöÄ Process Video</button>
            <span
              id="processSpinner"
              class="spinner hidden"
              aria-hidden="true"
            ></span>
          </div>

          <!-- progress ring -->
          <div
            id="progressArea"
            class="progress-wrapper hidden"
            aria-hidden="true"
          >
            <div class="progress-ring" id="progressRing">
              <svg viewBox="0 0 100 100" aria-hidden="true">
                <circle
                  cx="50"
                  cy="50"
                  r="44"
                  stroke="rgba(255,255,255,0.08)"
                  stroke-width="8"
                  fill="none"
                ></circle>
                <circle
                  id="progressCircle"
                  cx="50"
                  cy="50"
                  r="44"
                  stroke="#00e1ff"
                  stroke-width="8"
                  stroke-linecap="round"
                  fill="none"
                  stroke-dasharray="276.460"
                  stroke-dashoffset="276.460"
                ></circle>
              </svg>
              <div class="progress-text" id="progressText">0%</div>
            </div>
            <div>
              <div class="progress-label" id="progressLabel">Waiting...</div>
            </div>
          </div>

          <div id="status" class="status hidden"></div>

          <div id="platesSection" class="hidden">
            <h4 style="color: #bfefff; margin-top: 16px">
              üì∏ Cropped Plates (Stop-line Violations)
            </h4>
            <div id="plates" class="plates"></div>
          </div>
        </div>
      </div>

      <div
        id="errorMsg"
        class="hidden"
        style="
          color: #ffb3b3;
          margin-top: 14px;
          text-align: center;
          font-weight: 700;
        "
      ></div>
    </div>

    <script>
      (function () {
        // Elements
        const dropZone = document.getElementById("dropZone");
        const fileInput = document.getElementById("fileInput");
        const dropMsg = document.getElementById("dropMsg");
        const previewContainer = document.getElementById("previewContainer");
        const inputVideo = document.getElementById("inputVideo");
        const fileInfo = document.getElementById("fileInfo");
        const processBtn = document.getElementById("processBtn");
        const processSpinner = document.getElementById("processSpinner");
        const statusEl = document.getElementById("status");
        const platesSection = document.getElementById("platesSection");
        const platesEl = document.getElementById("plates");
        const errorMsg = document.getElementById("errorMsg");

        const progressArea = document.getElementById("progressArea");
        const progressCircle = document.getElementById("progressCircle");
        const progressText = document.getElementById("progressText");
        const progressLabel = document.getElementById("progressLabel");

        // geometry
        const R = 44;
        const circumference = 2 * Math.PI * R;
        progressCircle.style.strokeDasharray = `${circumference}`;
        progressCircle.style.strokeDashoffset = `${circumference}`;

        // state
        let currentFile = null;
        let currentPreviewURL = null;
        let simulatedTimer = null;
        let simulatedValue = 0;
        let pollingTimer = null;

        // config (tweak if you want)
        const SIMULATED_MAX_BEFORE_FINAL = 95; // how far simulated progress goes while waiting
        const SIMULATED_STEP_MS = 800; // how often simulated progress increments
        const SIMULATED_STEP_INC = 1; // percent increment per tick (will feel smooth)
        const POLL_INTERVAL_MS = 1500; // polling interval for job status

        function showError(text) {
          errorMsg.textContent = "‚ùå " + text;
          errorMsg.classList.remove("hidden");
          console.error("Error:", text);
          setTimeout(() => errorMsg.classList.add("hidden"), 7000);
        }

        function setPreviewURL(file) {
          if (currentPreviewURL) {
            URL.revokeObjectURL(currentPreviewURL);
            currentPreviewURL = null;
          }
          if (!file) {
            inputVideo.removeAttribute("src");
            return;
          }
          currentPreviewURL = URL.createObjectURL(file);
          inputVideo.src = currentPreviewURL;
          inputVideo.load();
        }

        function updateProgress(pct, label) {
          pct = Math.max(0, Math.min(100, Math.round(pct)));
          const offset = circumference - (pct / 100) * circumference;
          progressCircle.style.strokeDashoffset = `${offset}`;
          progressText.textContent = `${pct}%`;
          progressLabel.textContent =
            label || (pct < 100 ? "Processing..." : "Done");
        }

        function startSimulatedProgress(fromPct = 0) {
          stopSimulatedProgress();
          simulatedValue = Math.max(
            0,
            Math.min(SIMULATED_MAX_BEFORE_FINAL, Math.round(fromPct))
          );
          updateProgress(simulatedValue, "Processing...");
          progressArea.classList.remove("hidden");

          simulatedTimer = setInterval(() => {
            // gentle exponential-like approach to SIMULATED_MAX_BEFORE_FINAL
            if (simulatedValue < SIMULATED_MAX_BEFORE_FINAL) {
              simulatedValue = Math.min(
                SIMULATED_MAX_BEFORE_FINAL,
                simulatedValue + SIMULATED_STEP_INC
              );
              updateProgress(simulatedValue, "Processing...");
            } else {
              // stay near max until real response
              updateProgress(simulatedValue, "Processing...");
            }
          }, SIMULATED_STEP_MS);
        }

        function stopSimulatedProgress() {
          if (simulatedTimer) {
            clearInterval(simulatedTimer);
            simulatedTimer = null;
          }
        }

        function startPolling(jobId, onComplete) {
          stopPolling();
          if (!jobId) return;
          progressArea.classList.remove("hidden");
          progressLabel.textContent = "Queued...";
          pollingTimer = setInterval(async () => {
            try {
              const res = await fetch(
                `/api/stopline_status?job_id=${encodeURIComponent(jobId)}`,
                { cache: "no-store" }
              );
              if (!res.ok) {
                console.warn("Poll returned", res.status);
                return;
              }
              const json = await res.json();
              // expected: { progress: 42, status: "processing", plates: [...] } or { status:"completed", plates: [...] }
              if (typeof json.progress === "number") {
                updateProgress(
                  json.progress,
                  (json.status || "Processing").toString()
                );
              } else if (json.status === "processing") {
                // bump progress gently if unknown
                const curr = parseInt(progressText.textContent) || 0;
                updateProgress(Math.min(95, curr + 2), json.status);
              }

              if (
                json.status === "completed" ||
                json.status === "done" ||
                json.status === "finished"
              ) {
                stopPolling();
                stopSimulatedProgress();
                updateProgress(100, "Completed");
                if (Array.isArray(json.plates) && json.plates.length > 0)
                  renderPlates(json.plates);
                if (typeof onComplete === "function") onComplete(json);
              }
            } catch (err) {
              console.error("Polling error", err);
            }
          }, POLL_INTERVAL_MS);
        }

        function stopPolling() {
          if (pollingTimer) {
            clearInterval(pollingTimer);
            pollingTimer = null;
          }
        }

        function renderPlates(plates) {
          platesEl.innerHTML = "";
          if (!Array.isArray(plates) || plates.length === 0) {
            platesSection.classList.add("hidden");
            return;
          }
          platesSection.classList.remove("hidden");
          plates.forEach((p, idx) => {
            const a = document.createElement("a");
            a.href = p;
            a.target = "_blank";
            a.rel = "noopener noreferrer";
            a.download = "";
            const img = document.createElement("img");
            img.src = p.startsWith("data:") ? p : p + "?v=" + Date.now();
            img.className = "plate-thumb";
            img.alt = `Violation crop ${idx + 1}`;
            img.onerror = () => console.error("Failed to load plate", p);
            a.appendChild(img);
            platesEl.appendChild(a);
          });
        }

        // drag & drop + file selection handlers (same as before)
        dropZone.addEventListener("click", () => fileInput.click());
        dropZone.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            fileInput.click();
          }
        });
        dropZone.addEventListener("dragover", (e) => {
          e.preventDefault();
          dropZone.classList.add("dragover");
        });
        dropZone.addEventListener("dragleave", () =>
          dropZone.classList.remove("dragover")
        );
        dropZone.addEventListener("drop", (e) => {
          e.preventDefault();
          dropZone.classList.remove("dragover");
          const f = e.dataTransfer.files && e.dataTransfer.files[0];
          if (f) handleFile(f);
        });
        fileInput.addEventListener("change", (e) => {
          const f = e.target.files && e.target.files[0];
          if (f) handleFile(f);
        });

        function handleFile(file) {
          if (!file) return;
          const ext = (file.name.split(".").pop() || "").toLowerCase();
          const allowedExt = ["mp4", "mov", "avi", "mkv", "webm"];
          const allowedMimes = [
            "video/mp4",
            "video/quicktime",
            "video/x-msvideo",
            "video/avi",
            "video/mov",
            "video/x-matroska",
            "video/webm",
          ];
          if (!allowedExt.includes(ext) && !allowedMimes.includes(file.type)) {
            showError(
              "Unsupported file type. Please upload MP4/MOV/AVI/MKV/WebM video."
            );
            return;
          }
          if (file.size > 150 * 1024 * 1024) {
            showError(
              "File too large (max 150MB). Please choose a smaller video."
            );
            return;
          }

          currentFile = file;
          stopPolling();
          stopSimulatedProgress();
          updateProgress(0, "Waiting...");
          progressArea.classList.add("hidden");
          previewContainer.classList.remove("hidden");
          dropMsg.textContent = `‚úì Selected: ${file.name}`;
          setPreviewURL(file);
          fileInfo.textContent = `${(file.size / 1024 / 1024).toFixed(
            2
          )} MB ‚Ä¢ ${file.name}`;

          inputVideo.onloadedmetadata = () => {
            const duration = inputVideo.duration || 0;
            const maxSeconds = 90;
            if (duration > maxSeconds) {
              showError(
                `Video is too long (${Math.round(
                  duration
                )}s). Please upload under ${maxSeconds}s.`
              );
              currentFile = null;
              fileInput.value = "";
              setPreviewURL(null);
              previewContainer.classList.add("hidden");
            }
            inputVideo.onloadedmetadata = null;
          };
        }

        // MAIN: upload + progress handling with simulated progress fallback
        processBtn.addEventListener("click", () => {
          if (!currentFile) {
            showError("Please select a video first.");
            return;
          }

          processBtn.disabled = true;
          processSpinner.classList.remove("hidden");
          statusEl.classList.remove("hidden");
          statusEl.textContent =
            "üîÑ Uploading & processing... (this may take a while)";

          const fd = new FormData();
          fd.append("video", currentFile);

          const xhr = new XMLHttpRequest();
          xhr.open("POST", "/api/stopline_upload", true);

          // Show progress area and start at 0
          progressArea.classList.remove("hidden");
          updateProgress(0, "Uploading...");

          // upload progress (real)
          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
              const pct = Math.round((e.loaded / e.total) * 100);
              updateProgress(pct, `Uploading (${pct}%)`);
            }
          };

          // When upload finished but server processing still ongoing,
          // XHR stays pending until server returns. We'll start simulated progress here
          xhr.onreadystatechange = function () {
            // readyState 2/3/4 - but we care when upload finished and request is sent: readyState 2 or 3 isn't reliable cross-server
            // so we start simulatedProgress right after send() below.
          };

          xhr.timeout = 10 * 60 * 1000; // 10 minutes
          xhr.ontimeout = function () {
            processBtn.disabled = false;
            processSpinner.classList.add("hidden");
            showError(
              "Upload timed out. Try a shorter video or faster connection."
            );
            statusEl.textContent = "‚ùå Processing failed (timeout)";
            updateProgress(0, "Timeout");
            stopSimulatedProgress();
            stopPolling();
          };

          xhr.onload = function () {
            processBtn.disabled = false;
            processSpinner.classList.add("hidden");
            stopSimulatedProgress();
            stopPolling();

            if (xhr.status < 200 || xhr.status >= 300) {
              showError(`Server returned ${xhr.status}`);
              statusEl.textContent = "‚ùå Processing failed";
              updateProgress(0, "Server error");
              console.error("Server error:", xhr.responseText);
              return;
            }

            let json;
            try {
              json = JSON.parse(xhr.responseText);
            } catch (err) {
              showError("Invalid server response (not JSON).");
              statusEl.textContent = "‚ùå Processing failed";
              updateProgress(0, "Invalid response");
              console.error("JSON parse error:", err);
              return;
            }

            if (!json.success) {
              showError(json.error || "Processing failed");
              statusEl.textContent = "‚ùå Processing failed";
              updateProgress(0, "Processing failed");
              return;
            }

            // If server responded with immediate plates -> done
            if (Array.isArray(json.plates) && json.plates.length > 0) {
              updateProgress(100, "Completed");
              renderPlates(json.plates);
              statusEl.textContent =
                "‚úÖ " + (json.message || "Processing complete");
              return;
            }

            // If server returned a job id -> start polling
            const jobId = json.job_id || json.task_id;
            if (jobId) {
              // start polling for accurate progress
              updateProgress(5, "Queued");
              statusEl.textContent = "üîÑ Processing on server...";
              startPolling(jobId, (finalJson) => {
                if (
                  Array.isArray(finalJson.plates) &&
                  finalJson.plates.length > 0
                ) {
                  renderPlates(finalJson.plates);
                  statusEl.textContent = "‚úÖ Processing complete";
                } else {
                  statusEl.textContent =
                    "‚úÖ Processing complete (no plates returned)";
                }
              });
              return;
            }

            // fallback if no job id & no plates: treat as complete
            updateProgress(100, "Completed");
            statusEl.textContent =
              "‚úÖ " + (json.message || "Processing complete");
          };

          xhr.onerror = function () {
            processBtn.disabled = false;
            processSpinner.classList.add("hidden");
            showError("Upload failed (network error).");
            statusEl.textContent = "‚ùå Processing failed";
            updateProgress(0, "Network error");
            stopSimulatedProgress();
            stopPolling();
            console.error("XHR network error");
          };

          // send + start simulated progress (in case server blocks before responding)
          try {
            xhr.send(fd);
            // Start simulated progress AFTER send, so it runs while server processes.
            // But if server supports job_id and returns immediately, polling will override simulated progress.
            startSimulatedProgress(
              Math.max(
                parseInt(progressText.textContent) || 0,
                /*start from current upload pct*/ 0
              )
            );
          } catch (err) {
            processBtn.disabled = false;
            processSpinner.classList.add("hidden");
            showError("Failed to send upload request.");
            statusEl.textContent = "‚ùå Processing failed";
            updateProgress(0, "Send failed");
            console.error("Failed to send XHR:", err);
          }
        });

        window.addEventListener("beforeunload", () => {
          if (currentPreviewURL) URL.revokeObjectURL(currentPreviewURL);
          stopSimulatedProgress();
          stopPolling();
        });

        console.log(
          "Stop-line detection page loaded (simulated + polling progress)."
        );
      })();
    </script>
  </body>
</html>
